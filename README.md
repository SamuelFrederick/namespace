# namespace

This package is intended to aid in fuzzy merging names in different formats.

Model weights were generated by fine-tuning RoBERTa (Large) on an AWS g5.2xlarge instance using Multiple Negatives Ranking Loss and names sampled from public voter files with noise added to capture common naming differences across datasets.

For name matching, MNRL fine-tuned model weights were further fine-tuned for match classification using samples of names from voter files. I added noise to names and randomly varied whether names were matched with one another or not. Among non-matching names, I ensured that approximately 20% of name pairs had matching last names.

## Recommended Model Weights

Recommended model weights are available [here](https://huggingface.co/SamFrederick). 

| Model                                                                 | Training Size | Base Model    |
| --------------------------------------------------------------------- | ------------- | ------------- |
| [namespace500k](https://huggingface.co/SamFrederick/namespace500k) | 500,000       | RoBERTa Large |
| [namespace1m](https://huggingface.co/SamFrederick/namespace1m)     | 1,000,000     | RoBERTa Large |
| [namematch500k](https://huggingface.co/SamFrederick/namematch500k) | 500,000       | namespace500k |
| [namematch1m](https://huggingface.co/SamFrederick/namematch1m)     | 1,000,000     | namespace1m   |
| [namematch2m](https://huggingface.co/SamFrederick/namematch2m)     | 2,000,000     | namespace1m   |


# Usage

## Installation

```bash         
pip install git+https://github.com/SamuelFrederick/namespace.git
```

## Embedding Names

The EmbedName class returns embeddings for the names as well as cosine similarity between names or lists of names. 

```python
from namespace import EmbedName

embedder = EmbedName('SamFrederick/namespace1m')
embedder.embed_name('John Smith')
embedder.cosine_similarity('John Smith', 'Smith, Jonathan E.')
```

## Filtering Names

The FilterName class returns the closest names in terms of cosine similarity. 

```python
from namespace import FilterName

name1 = [
    'John Smith', 'Mark Twain', 'Ernest Hemingway', 
    'F. Scott Fitzgerald', 'Jane Austen', 'Charles Dickens', 
    'Henry David Thoreau', 'Walt Whitman', 'Emily Dickinson'
    ]
name2 = [
    'Jonathan Smith', 'Twain, Mark', 'Marcus Twain', 
    'Ernie Hemingway', 'Hemingway, E.', 'Scott Fitzgerald', 
    'Charlie Dickens', 'Dickens, Chuck', 'Jane Austen', 
    'Henry Thoreau', 'Thoreau, David', 'Walter Whitman', 
    'Whitman, Walt, Jr.', 'Emily Dickinson', 'Dr. Emily Dickinson'
    ]

filterer = FilterName(
    embedding_model = 'SamFrederick/namespace1m', 
    return_sim = True, 
    k = 3, 
    device = 'mps'
    )
filterer.filter_names(name1, name2)
```

## Matching Names

The `predict_match` function returns the probability that names match one another. 

```python
from namespace import MatchName

matcher = MatchName(
    classification_model = 'SamFrederick/namematch2m', 
    device = 'mps'
    )
matcher.predict_match('John Smith', 'Smith, John E.')
```

### All Matches Between Two Name Lists

This function takes two lists of names, generates all possible combinations names from each list, and predicts whether each combination is a match. It returns a DataFrame with columns name1, name2, prob. 

```python
from namespace import MatchName

name1 = [
    'John Smith', 'Mark Twain', 'Ernest Hemingway', 
    'F. Scott Fitzgerald', 'Jane Austen', 'Charles Dickens', 
    'Henry David Thoreau', 'Walt Whitman', 'Emily Dickinson'
    ]
name2 = [
    'Jonathan Smith', 'Twain, Mark', 'Marcus Twain', 
    'Ernie Hemingway', 'Hemingway, E.', 'Scott Fitzgerald', 
    'Charlie Dickens', 'Dickens, Chuck', 'Jane Austen', 
    'Henry Thoreau', 'Thoreau, David', 'Walter Whitman', 
    'Whitman, Walt, Jr.', 'Emily Dickinson', 'Dr. Emily Dickinson'
    ]

matcher = MatchName(
    classification_model = 'SamFrederick/namematch2m', 
    device = 'mps'
    )
matcher.all_probs(name1, name2)
```

### Improving Speed of All Matches with Filtering

If you know there are likely to only be a certain number of possible matches for each name, you can speed up the matching process by predicting matches only for a subset of name pairs rather than all name pairs. This will first filter to the top k closest names, and then, predict whether these names actually match. 

```python
from namespace import FilterName, MatchName

name1 = [
    'John Smith', 'Mark Twain', 'Ernest Hemingway', 
    'F. Scott Fitzgerald', 'Jane Austen', 'Charles Dickens', 
    'Henry David Thoreau', 'Walt Whitman', 'Emily Dickinson'
    ]
name2 = [
    'Jonathan Smith', 'Twain, Mark', 'Marcus Twain', 
    'Ernie Hemingway', 'Hemingway, E.', 'Scott Fitzgerald', 
    'Charlie Dickens', 'Dickens, Chuck', 'Jane Austen', 
    'Henry Thoreau', 'Thoreau, David', 'Walter Whitman', 
    'Whitman, Walt, Jr.', 'Emily Dickinson', 'Dr. Emily Dickinson'
    ]

filterer = FilterName(
    embedding_model = 'SamFrederick/namespace1m', 
    k = 3, 
    device = 'mps'
    )
matcher = MatchName(
    classification_model = 'SamFrederick/namematch2m', 
    filter = filterer, 
    device = 'mps'
    )
matcher.all_probs(name1, name2)
```

## Merging Names

If you have two datasets containing names, you can merge these datsets using the `merge_name` function. If there are columns you would like to exact match on, you can specify these columns using the `left_exact` and `right_exact` arguments. The function will first exact match on these columns and then fuzzy match names within the groups created by the exact match columns. 


```python
from namespace import FilterName, MatchName

filterer = FilterName(
    embedding_model = 'SamFrederick/namespace1m', 
    k = 3, 
    device = 'mps'
    )
matcher = MatchName(
    classification_model = 'SamFrederick/namematch2m', 
    filter = filterer, 
    device = 'mps'
    )
matcher.merge_name(
    df1, 
    df2, 
    how = 'left', 
    left_name_col = 'name1', 
    right_name_col = 'name2', 
    left_exact = ['genre', 'century'], 
    right_exact = ['genre', 'century'], 
    merge_threshold = 0.5, 
    return_marginal = False, 
    batch_size = 100
)
```

## De-Duplicating Names

If you have a dataset containing multiple, messy versions of names, you can deduplicate those names using the `dedupe_name` function. 

```python
from namespace import FilterName, MatchName

filterer = FilterName(
    embedding_model = 'SamFrederick/namespace1m', 
    k = 3, 
    device = 'mps'
    )
matcher = MatchName(
    classification_model = 'SamFrederick/namematch2m', 
    filter = filterer, 
    device = 'mps'
    )
matcher.dedupe_name(
    df, 
    name_col = 'name', 
    exact = ['genre', 'century'], 
    merge_threshold = 0.5, 
    return_marginal = False, 
    batch_size = 100
)
```
